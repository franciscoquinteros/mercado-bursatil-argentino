{
  "name": "Mercado Argentino con yFinance",
  "description": "Un contexto que permite consultar activos del mercado bursátil argentino utilizando datos en tiempo real desde Yahoo Finance.",
  "system_prompt": "Actuá como un analista financiero especializado en el mercado argentino. Utilizá la librería yfinance para responder sobre precios históricos, rendimiento, correlaciones y ratios financieros de acciones argentinas.",
  "sample_conversation": [
    {
      "role": "user",
      "content": "¿Cuál fue el rendimiento de GGAL en los últimos 3 meses?"
    },
    {
      "role": "assistant",
      "content": "Para calcular el rendimiento de GGAL, voy a obtener sus precios desde hace 90 días hasta hoy con yfinance. Dame un momento..."
    }
  ],
  "code": {
    "files": [
      {
        "path": "main.py",
        "language": "python",
        "content": "\"\"\"\nIntegración de yfinance con el Modelo de Contexto del Protocolo (MCP)\npara el Mercado Bursátil Argentino\n\"\"\"\n\nimport yfinance as yf\nimport pandas as pd\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional, Union, Any\nfrom datetime import datetime, timedelta\nimport json\nimport logging\nfrom enum import Enum\n\n# Configuración de logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(\"MCP-Argentina-YFinance\")\n\n# Definición de enumeraciones (mantenemos las del MCP original)\nclass TipoActivo(str, Enum):\n    ACCION = \"ACCION\"\n    CEDEAR = \"CEDEAR\"\n    BONO = \"BONO\"\n    ETF = \"ETF\"\n    OPCION = \"OPCION\"\n    FUTURO = \"FUTURO\"\n\nclass PanelMercado(str, Enum):\n    LIDER = \"LIDER\"\n    GENERAL = \"GENERAL\"\n    PYMES = \"PYMES\"\n    BONOS = \"BONOS\"\n    LETRAS = \"LETRAS\"\n\nclass Mercado(str, Enum):\n    BYMA = \"BYMA\"\n    MAE = \"MAE\"\n    MAV = \"MAV\"\n    ROFEX = \"ROFEX\"\n    NYSE = \"NYSE\"\n    NASDAQ = \"NASDAQ\"\n    \nclass Moneda(str, Enum):\n    ARS = \"ARS\"\n    USD = \"USD\"\n    USD_LINKED = \"USD-LINKED\"\n    EUR = \"EUR\"\n\nclass Intervalo(str, Enum):\n    MINUTO_1 = \"1m\"\n    MINUTO_2 = \"2m\"\n    MINUTO_5 = \"5m\"\n    MINUTO_15 = \"15m\"\n    MINUTO_30 = \"30m\"\n    MINUTO_60 = \"60m\"\n    MINUTO_90 = \"90m\"\n    HORA_1 = \"1h\"\n    DIA_1 = \"1d\"\n    DIA_5 = \"5d\"\n    SEMANA_1 = \"1wk\"\n    MES_1 = \"1mo\"\n    MES_3 = \"3mo\"\n\nclass EstadoRespuesta(str, Enum):\n    OK = \"OK\"\n    ERROR = \"ERROR\"\n\nclass CodigoError(str, Enum):\n    DATA_001 = \"DATA_001\"  # Símbolo no encontrado\n    DATA_002 = \"DATA_002\"  # Datos no disponibles para el rango solicitado\n    DATA_003 = \"DATA_003\"  # Error en la obtención de datos\n    PARAM_001 = \"PARAM_001\"  # Parámetros incorrectos\n\n# Mapeo de símbolos argentinos a símbolos de Yahoo Finance\n# Los activos argentinos en Yahoo Finance suelen tener sufijos como .BA para Buenos Aires\nSIMBOLOS_MAPPING = {\n    # Acciones líderes\n    \"GGAL\": \"GGAL.BA\",\n    \"PAMP\": \"PAMP.BA\",\n    \"YPF\": \"YPFD.BA\",  # Cambiado de YPF.BA a YPFD.BA que es el correcto\n    \"YPFD\": \"YPFD.BA\",\n    \"TXAR\": \"TXAR.BA\",\n    \"BYMA\": \"BYMA.BA\",\n    \"BBAR\": \"BBAR.BA\",\n    \"CEPU\": \"CEPU.BA\",\n    \"TRAN\": \"TRAN.BA\",\n    \"TGNO4\": \"TGNO4.BA\",\n    \"TGSU2\": \"TGSU2.BA\",\n    \"LOMA\": \"LOMA.BA\",\n    \"BMA\": \"BMA.BA\",\n    \"SUPV\": \"SUPV.BA\",\n    \"CRES\": \"CRES.BA\",\n    \"ALUA\": \"ALUA.BA\",\n    \"COME\": \"COME.BA\",\n    \"MIRG\": \"MIRG.BA\",\n    \"HARG\": \"HARG.BA\",\n    \"VALO\": \"VALO.BA\",\n    \n    # ADRs (cotizados en USD)\n    \"GGAL.ADR\": \"GGAL\",\n    \"YPF.ADR\": \"YPF\",  # YPF que cotiza en NYSE\n    \"BMA.ADR\": \"BMA\",\n    \"SUPV.ADR\": \"SUPV\",\n    \"LOMA.ADR\": \"LOMA\",\n    \"BBAR.ADR\": \"BBAR\",\n    \"PAM.ADR\": \"PAM\",  # Pampa Energía ADR\n    \"TEO.ADR\": \"TEO\",  # Telecom Argentina ADR\n    \"TGS.ADR\": \"TGS\",  # Transportadora Gas del Sur ADR\n    \n    # ETFs relacionados con Argentina\n    \"ARGT\": \"ARGT\",    # Global X MSCI Argentina ETF\n    \n    # Índices\n    \"MERVAL\": \"^MERV\", # Índice Merval\n}\n\n# Clase adaptadora para convertir datos de yfinance al formato MCP\n@dataclass\nclass ActivoFinanciero:\n    simbolo: str\n    tipo: TipoActivo\n    denominacion: str\n    panel: PanelMercado = PanelMercado.LIDER\n    mercado: Mercado = Mercado.BYMA\n    moneda: Moneda = Moneda.ARS\n    codigo_isin: Optional[str] = None\n    codigo_cfi: Optional[str] = None\n    simbolo_yahoo: Optional[str] = None\n    \n    def to_dict(self):\n        return {\n            \"simbolo\": self.simbolo,\n            \"tipo\": self.tipo.value,\n            \"denominacion\": self.denominacion,\n            \"panel\": self.panel.value,\n            \"mercado\": self.mercado.value,\n            \"moneda\": self.moneda.value,\n            \"codigoISIN\": self.codigo_isin,\n            \"codigoCFI\": self.codigo_cfi,\n            \"simboloYahoo\": self.simbolo_yahoo\n        }\n    \n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]):\n        return cls(\n            simbolo=data[\"simbolo\"],\n            tipo=TipoActivo(data[\"tipo\"]),\n            denominacion=data[\"denominacion\"],\n            panel=PanelMercado(data[\"panel\"]) if \"panel\" in data else PanelMercado.LIDER,\n            mercado=Mercado(data[\"mercado\"]) if \"mercado\" in data else Mercado.BYMA,\n            moneda=Moneda(data[\"moneda\"]) if \"moneda\" in data else Moneda.ARS,\n            codigo_isin=data.get(\"codigoISIN\"),\n            codigo_cfi=data.get(\"codigoCFI\"),\n            simbolo_yahoo=data.get(\"simboloYahoo\")\n        )\n\n@dataclass\nclass Cotizacion:\n    simbolo: str\n    timestamp: datetime\n    apertura: float\n    maximo: float\n    minimo: float\n    cierre: float\n    volumen_nominal: float\n    volumen_monto: float = 0.0\n    cantidad_operaciones: int = 0\n    ajustado: bool = True\n    \n    def to_dict(self):\n        return {\n            \"simbolo\": self.simbolo,\n            \"timestamp\": self.timestamp.isoformat(),\n            \"apertura\": self.apertura,\n            \"maximo\": self.maximo,\n            \"minimo\": self.minimo,\n            \"cierre\": self.cierre,\n            \"volumenNominal\": self.volumen_nominal,\n            \"volumenMonto\": self.volumen_monto,\n            \"cantidadOperaciones\": self.cantidad_operaciones,\n            \"ajustado\": self.ajustado\n        }\n    \n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]):\n        return cls(\n            simbolo=data[\"simbolo\"],\n            timestamp=datetime.fromisoformat(data[\"timestamp\"]),\n            apertura=data[\"apertura\"],\n            maximo=data[\"maximo\"],\n            minimo=data[\"minimo\"],\n            cierre=data[\"cierre\"],\n            volumen_nominal=data[\"volumenNominal\"],\n            volumen_monto=data.get(\"volumenMonto\", 0.0),\n            cantidad_operaciones=data.get(\"cantidadOperaciones\", 0),\n            ajustado=data.get(\"ajustado\", True)\n        )\n\n# Clases para solicitudes\n@dataclass\nclass SolicitudHistorico:\n    simbolo: str\n    desde: Optional[datetime] = None\n    hasta: Optional[datetime] = None\n    intervalo: Intervalo = Intervalo.DIA_1\n    ajustado: bool = True\n    \n    def to_dict(self):\n        return {\n            \"simbolo\": self.simbolo,\n            \"desde\": self.desde.isoformat() if self.desde else None,\n            \"hasta\": self.hasta.isoformat() if self.hasta else None,\n            \"intervalo\": self.intervalo.value,\n            \"ajustado\": self.ajustado\n        }\n\n@dataclass\nclass MetadataHistorico:\n    simbolo: str\n    desde: datetime\n    hasta: datetime\n    intervalo: str\n    registros: int\n    ajustado: bool\n    \n    def to_dict(self):\n        return {\n            \"simbolo\": self.simbolo,\n            \"desde\": self.desde.isoformat(),\n            \"hasta\": self.hasta.isoformat(),\n            \"intervalo\": self.intervalo,\n            \"registros\": self.registros,\n            \"ajustado\": self.ajustado\n        }\n\n@dataclass\nclass RespuestaHistorico:\n    estado: EstadoRespuesta\n    datos: List[Cotizacion] = field(default_factory=list)\n    metadata: Optional[MetadataHistorico] = None\n    mensaje: Optional[str] = None\n    codigo_error: Optional[CodigoError] = None\n    \n    def to_dict(self):\n        result = {\n            \"estado\": self.estado.value\n        }\n        \n        if self.estado == EstadoRespuesta.OK:\n            result[\"datos\"] = [cotizacion.to_dict() for cotizacion in self.datos]\n            result[\"metadata\"] = self.metadata.to_dict() if self.metadata else None\n        else:\n            result[\"mensaje\"] = self.mensaje\n            result[\"codigo\"] = self.codigo_error.value if self.codigo_error else None\n            \n        return result\n\n# Cliente de YFinance para el MCP\nclass ClienteYFinanceMCP:\n    def __init__(self):\n        self.simbolos_mapping = SIMBOLOS_MAPPING\n        self._activos_cache = {}  # Caché para información de activos\n    \n    def _get_yahoo_symbol(self, simbolo: str) -> str:\n        \"\"\"Obtiene el símbolo correspondiente de Yahoo Finance\"\"\"\n        if simbolo in self.simbolos_mapping:\n            return self.simbolos_mapping[simbolo]\n        # Si el símbolo no está en el mapeo, intentamos agregando .BA\n        if not simbolo.endswith('.BA') and not simbolo.endswith('.ADR'):\n            posible_simbolo = f\"{simbolo}.BA\"\n            logger.info(f\"Símbolo no encontrado en mapeo, intentando con {posible_simbolo}\")\n            return posible_simbolo\n        return simbolo\n    \n    def _convert_yf_history_to_cotizaciones(self, df: pd.DataFrame, simbolo: str) -> List[Cotizacion]:\n        \"\"\"Convierte un DataFrame de historial de yfinance a una lista de Cotizacion\"\"\"\n        cotizaciones = []\n        \n        # Verificar si el DataFrame está vacío\n        if df.empty:\n            return cotizaciones\n        \n        for index, row in df.iterrows():\n            # Verificar si tenemos todos los datos necesarios\n            if pd.isna(row['Open']) or pd.isna(row['High']) or pd.isna(row['Low']) or pd.isna(row['Close']):\n                continue\n                \n            cotizacion = Cotizacion(\n                simbolo=simbolo,\n                timestamp=index.to_pydatetime(),\n                apertura=float(row['Open']),\n                maximo=float(row['High']),\n                minimo=float(row['Low']),\n                cierre=float(row['Close']),\n                volumen_nominal=float(row['Volume']) if 'Volume' in row and not pd.isna(row['Volume']) else 0.0,\n                ajustado=True\n            )\n            cotizaciones.append(cotizacion)\n        \n        return cotizaciones\n    \n    def obtener_historico(self, solicitud: SolicitudHistorico) -> RespuestaHistorico:\n        \"\"\"Obtiene datos históricos de cotizaciones usando yfinance\"\"\"\n        try:\n            # Obtener símbolo de Yahoo Finance\n            simbolo_yahoo = self._get_yahoo_symbol(solicitud.simbolo)\n            \n            # Preparar fechas\n            desde = solicitud.desde if solicitud.desde else datetime.now() - timedelta(days=365)\n            hasta = solicitud.hasta if solicitud.hasta else datetime.now()\n            \n            # Obtener intervalo de yfinance\n            intervalo = solicitud.intervalo.value\n            \n            logger.info(f\"Obteniendo datos para {simbolo_yahoo} desde {desde} hasta {hasta} con intervalo {intervalo}\")\n            \n            # Obtener datos de yfinance con manejo de errores más robusto\n            try:\n                ticker = yf.Ticker(simbolo_yahoo)\n                df = ticker.history(\n                    start=desde.strftime('%Y-%m-%d'),\n                    end=hasta.strftime('%Y-%m-%d'),\n                    interval=intervalo,\n                    auto_adjust=solicitud.ajustado\n                )\n            except Exception as ticker_error:\n                logger.error(f\"Error específico de yfinance: {ticker_error}\")\n                return RespuestaHistorico(\n                    estado=EstadoRespuesta.ERROR,\n                    mensaje=f\"Error al obtener datos de Yahoo Finance para el símbolo {simbolo_yahoo}: {str(ticker_error)}\",\n                    codigo_error=CodigoError.DATA_003\n                )\n            \n            # Si no hay datos, devolver error\n            if df.empty:\n                logger.warning(f\"DataFrame vacío para {simbolo_yahoo}\")\n                return RespuestaHistorico(\n                    estado=EstadoRespuesta.ERROR,\n                    mensaje=f\"No se encontraron datos para el símbolo {solicitud.simbolo} ({simbolo_yahoo}) en el período solicitado\",\n                    codigo_error=CodigoError.DATA_002\n                )\n            \n            # Convertir a formato MCP\n            cotizaciones = self._convert_yf_history_to_cotizaciones(df, solicitud.simbolo)\n            \n            if not cotizaciones:\n                logger.warning(f\"No se pudieron convertir los datos para {simbolo_yahoo}\")\n                return RespuestaHistorico(\n                    estado=EstadoRespuesta.ERROR,\n                    mensaje=f\"Los datos obtenidos para {solicitud.simbolo} ({simbolo_yahoo}) no pudieron ser procesados\",\n                    codigo_error=CodigoError.DATA_003\n                )\n            \n            # Crear metadata\n            metadata = MetadataHistorico(\n                simbolo=solicitud.simbolo,\n                desde=cotizaciones[0].timestamp,\n                hasta=cotizaciones[-1].timestamp,\n                intervalo=intervalo,\n                registros=len(cotizaciones),\n                ajustado=solicitud.ajustado\n            )\n            \n            return RespuestaHistorico(\n                estado=EstadoRespuesta.OK,\n                datos=cotizaciones,\n                metadata=metadata\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error al obtener datos históricos: {e}\")\n            return RespuestaHistorico(\n                estado=EstadoRespuesta.ERROR,\n                mensaje=f\"Error en la obtención de datos: {str(e)}\",\n                codigo_error=CodigoError.DATA_003\n            )\n    \n    def obtener_activo(self, simbolo: str) -> Optional[ActivoFinanciero]:\n        \"\"\"Obtiene información de un activo financiero usando yfinance\"\"\"\n        try:\n            # Verificar caché\n            if simbolo in self._activos_cache:\n                return self._activos_cache[simbolo]\n            \n            # Obtener símbolo de Yahoo Finance\n            simbolo_yahoo = self._get_yahoo_symbol(simbolo)\n            \n            # Obtener datos de yfinance con manejo de errores\n            try:\n                ticker = yf.Ticker(simbolo_yahoo)\n                \n                # Verificar si hay información disponible\n                try:\n                    info = ticker.info\n                    if not info or len(info) == 0:\n                        logger.warning(f\"No hay información disponible para {simbolo_yahoo}\")\n                        # Fallback: obtener el último precio para verificar existencia\n                        df = ticker.history(period=\"1d\")\n                        if df.empty:\n                            logger.error(f\"No se pudo confirmar la existencia de {simbolo_yahoo}\")\n                            return None\n                        \n                        # Si llegamos aquí, el ticker existe pero no hay info detallada\n                        info = {\"shortName\": simbolo_yahoo}\n                except Exception as info_error:\n                    logger.warning(f\"Error al obtener info del ticker {simbolo_yahoo}: {info_error}\")\n                    # Intentamos obtener al menos el historial para confirmar que existe\n                    df = ticker.history(period=\"1d\")\n                    if df.empty:\n                        raise Exception(f\"No se encontró el símbolo {simbolo_yahoo}\")\n                    \n                    # Si llegamos aquí, el ticker existe pero no hay info detallada\n                    info = {\"shortName\": simbolo_yahoo}\n                    \n            except Exception as ticker_error:\n                logger.error(f\"Error al obtener el ticker {simbolo_yahoo}: {ticker_error}\")\n                return None\n            \n            # Determinar tipo de activo\n            tipo = TipoActivo.ACCION\n            if simbolo_yahoo == \"^MERV\":\n                tipo = TipoActivo.BONO\n            elif simbolo_yahoo == \"ARGT\":\n                tipo = TipoActivo.ETF\n            elif simbolo.endswith('.ADR'):\n                tipo = TipoActivo.CEDEAR\n            \n            # Determinar mercado\n            mercado = Mercado.BYMA\n            if simbolo_yahoo.endswith('.BA'):\n                mercado = Mercado.BYMA\n            elif not '.' in simbolo_yahoo or simbolo_yahoo.startswith('^'):\n                mercado = Mercado.NYSE\n            \n            # Determinar moneda\n            moneda = Moneda.ARS\n            if mercado != Mercado.BYMA:\n                moneda = Moneda.USD\n            \n            # Obtener denominación con manejo de errores\n            denominacion = simbolo\n            if info:\n                if 'longName' in info and info['longName']:\n                    denominacion = info['longName']\n                elif 'shortName' in info and info['shortName']:\n                    denominacion = info['shortName']\n            \n            # Crear activo\n            activo = ActivoFinanciero(\n                simbolo=simbolo,\n                tipo=tipo,\n                denominacion=denominacion,\n                panel=PanelMercado.LIDER,\n                mercado=mercado,\n                moneda=moneda,\n                simbolo_yahoo=simbolo_yahoo\n            )\n            \n            # Guardar en caché\n            self._activos_cache[simbolo] = activo\n            \n            return activo\n            \n        except Exception as e:\n            logger.error(f\"Error general al obtener información del activo {simbolo}: {e}\")\n            return None\n    \n    def obtener_ultima_cotizacion(self, simbolo: str) -> Optional[Cotizacion]:\n        \"\"\"Obtiene la última cotización disponible para un símbolo\"\"\"\n        try:\n            # Obtener símbolo de Yahoo Finance\n            simbolo_yahoo = self._get_yahoo_symbol(simbolo)\n            \n            # Algunos símbolos pueden necesitar ajuste\n            if simbolo == \"YPF\" and simbolo_yahoo == \"YPF.BA\":\n                logger.info(f\"Ajustando símbolo YPF a YPFD.BA\")\n                simbolo_yahoo = \"YPFD.BA\"\n            \n            # Intentar obtener datos con manejo de errores\n            try:\n                logger.info(f\"Obteniendo última cotización para {simbolo_yahoo}\")\n                ticker = yf.Ticker(simbolo_yahoo)\n                df = ticker.history(period=\"1d\")\n                \n                if df.empty:\n                    # Si el DataFrame está vacío, intentamos con 5 días\n                    logger.warning(f\"DataFrame para 1d vacío, intentando con period='5d' para {simbolo_yahoo}\")\n                    df = ticker.history(period=\"5d\")\n                    \n                    if df.empty:\n                        # Si aún está vacío, intentamos con 1 mes\n                        logger.warning(f\"DataFrame para 5d vacío, intentando con period='1mo' para {simbolo_yahoo}\")\n                        df = ticker.history(period=\"1mo\")\n                \n                if df.empty:\n                    logger.error(f\"No se encontraron datos para {simbolo_yahoo} en ningún período\")\n                    return None\n                \n            except Exception as ticker_error:\n                logger.error(f\"Error específico de yfinance para {simbolo_yahoo}: {ticker_error}\")\n                return None\n            \n            # Convertir a formato MCP\n            cotizaciones = self._convert_yf_history_to_cotizaciones(df, simbolo)\n            \n            if not cotizaciones:\n                logger.warning(f\"No se pudieron convertir los datos para {simbolo_yahoo}\")\n                return None\n                \n            # Devolver la cotización más reciente\n            return cotizaciones[0]\n            \n        except Exception as e:\n            logger.error(f\"Error general al obtener última cotización para {simbolo}: {e}\")\n            return None\n    \n    def obtener_cotizaciones_multiples(self, simbolos: List[str]) -> Dict[str, Optional[Cotizacion]]:\n        \"\"\"Obtiene las últimas cotizaciones para múltiples símbolos\"\"\"\n        resultado = {}\n        \n        # Procesamos cada símbolo individualmente para mayor robustez\n        for simbolo in simbolos:\n            try:\n                # Intentamos obtener la última cotización para este símbolo específico\n                ultima_cotizacion = self.obtener_ultima_cotizacion(simbolo)\n                resultado[simbolo] = ultima_cotizacion\n            except Exception as e:\n                logger.error(f\"Error procesando {simbolo} individualmente: {e}\")\n                resultado[simbolo] = None\n        \n        return resultado\n    \n    def buscar_activos(self, query: str) -> List[ActivoFinanciero]:\n        \"\"\"Busca activos que coincidan con un query\"\"\"\n        resultados = []\n        \n        try:\n            # Buscar en Yahoo Finance\n            tickers = yf.Tickers.search(query)\n            \n            for ticker_info in tickers[:10]:  # Limitamos a 10 resultados\n                ticker_symbol = ticker_info.get('symbol', '')\n                \n                # Filtrar para activos argentinos\n                if '.BA' in ticker_symbol or ticker_symbol in self.simbolos_mapping.values():\n                    # Encontrar símbolo original si es posible\n                    simbolo_original = next(\n                        (k for k, v in self.simbolos_mapping.items() if v == ticker_symbol), \n                        ticker_symbol\n                    )\n                    \n                    activo = ActivoFinanciero(\n                        simbolo=simbolo_original,\n                        tipo=TipoActivo.ACCION,\n                        denominacion=ticker_info.get('shortName', ticker_symbol),\n                        simbolo_yahoo=ticker_symbol,\n                        mercado=Mercado.BYMA if '.BA' in ticker_symbol else Mercado.NYSE,\n                        moneda=Moneda.ARS if '.BA' in ticker_symbol else Moneda.USD\n                    )\n                    resultados.append(activo)\n            \n            return resultados\n            \n        except Exception as e:\n            logger.error(f\"Error en búsqueda de activos: {e}\")\n            return []\n\n# Ejemplos de uso\ndef ejemplo_uso():\n    # Inicializar cliente\n    cliente = ClienteYFinanceMCP()\n    \n    # Ejemplo 1: Obtener datos históricos de YPF\n    print(\"\\n--- Ejemplo 1: Datos históricos de YPF ---\")\n    solicitud = SolicitudHistorico(\n        simbolo=\"YPF\",\n        desde=datetime(2023, 1, 1),\n        hasta=datetime(2023, 1, 31),\n        intervalo=Intervalo.DIA_1\n    )\n    \n    respuesta = cliente.obtener_historico(solicitud)\n    \n    if respuesta.estado == EstadoRespuesta.OK:\n        print(f\"Se obtuvieron {len(respuesta.datos)} registros históricos\")\n        for cotizacion in respuesta.datos[:3]:  # Mostrar solo los primeros 3\n            print(f\"{cotizacion.timestamp.date()} - Apertura: {cotizacion.apertura:.2f}, Cierre: {cotizacion.cierre:.2f}\")\n    else:\n        print(f\"Error: {respuesta.mensaje}\")\n    \n    # Ejemplo 2: Obtener información de un activo\n    print(\"\\n--- Ejemplo 2: Información del activo GGAL ---\")\n    activo = cliente.obtener_activo(\"GGAL\")\n    if activo:\n        print(f\"Activo: {activo.denominacion} ({activo.simbolo})\")\n        print(f\"Tipo: {activo.tipo.value}, Mercado: {activo.mercado.value}, Moneda: {activo.moneda.value}\")\n        print(f\"Símbolo en Yahoo Finance: {activo.simbolo_yahoo}\")\n    else:\n        print(\"No se pudo obtener información del activo\")\n    \n    # Ejemplo 3: Obtener última cotización\n    print(\"\\n--- Ejemplo 3: Última cotización del Merval ---\")\n    ultima = cliente.obtener_ultima_cotizacion(\"MERVAL\")\n    if ultima:\n        print(f\"Fecha: {ultima.timestamp}\")\n        print(f\"Apertura: {ultima.apertura:.2f}, Máximo: {ultima.maximo:.2f}\")\n        print(f\"Mínimo: {ultima.minimo:.2f}, Cierre: {ultima.cierre:.2f}\")\n        print(f\"Volumen: {ultima.volumen_nominal}\")\n    else:\n        print(\"No se pudo obtener la última cotización\")\n    \n    # Ejemplo 4: Obtener cotizaciones múltiples\n    print(\"\\n--- Ejemplo 4: Cotizaciones múltiples ---\")\n    simbolos = [\"YPF\", \"GGAL\", \"PAMP\"]\n    cotizaciones = cliente.obtener_cotizaciones_multiples(simbolos)\n    \n    for simbolo, cotizacion in cotizaciones.items():\n        if cotizacion:\n            print(f\"{simbolo}: Cierre {cotizacion.cierre:.2f} ({cotizacion.timestamp.date()})\")\n        else:\n            print(f\"{simbolo}: No disponible\")\n\nif __name__ == \"__main__\":\n    ejemplo_uso()\n\n# Función para crear un conjunto de datos de ejemplo más amplio\ndef generar_datos_ejemplo():\n    \"\"\"Genera un conjunto de datos de ejemplo para análisis\"\"\"\n    cliente = ClienteYFinanceMCP()\n    \n    # Lista de símbolos importantes en el mercado argentino\n    simbolos = [\n        \"GGAL\", \"YPF\", \"PAMP\", \"TXAR\", \"BYMA\", \"BBAR\", \n        \"MERVAL\", \"ALUA\", \"CEPU\", \"COME\", \"CRES\"\n    ]\n    \n    # Obtener datos históricos de último año para cada símbolo\n    resultados = {}\n    desde = datetime.now() - timedelta(days=365)\n    hasta = datetime.now()\n    \n    for simbolo in simbolos:\n        print(f\"Obteniendo datos para {simbolo}...\")\n        solicitud = SolicitudHistorico(\n            simbolo=simbolo,\n            desde=desde,\n            hasta=hasta,\n            intervalo=Intervalo.DIA_1\n        )\n        \n        respuesta = cliente.obtener_historico(solicitud)\n        if respuesta.estado == EstadoRespuesta.OK:\n            resultados[simbolo] = respuesta.datos\n            print(f\"  ✓ Obtenidos {len(respuesta.datos)} registros\")\n        else:\n            print(f\"  ✗ Error: {respuesta.mensaje}\")\n    \n    # Calcular algunas estadísticas\n    print(\"\\nEstadísticas:\")\n    for simbolo, cotizaciones in resultados.items():\n        if not cotizaciones:\n            continue\n            \n        precios_cierre = [c.cierre for c in cotizaciones]\n        promedio = sum(precios_cierre) / len(precios_cierre)\n        minimo = min(precios_cierre)\n        maximo = max(precios_cierre)\n        \n        # Calcular variación porcentual\n        primer_precio = cotizaciones[0].cierre\n        ultimo_precio = cotizaciones[-1].cierre\n        variacion = (ultimo_precio - primer_precio) / primer_precio * 100\n        \n        print(f\"{simbolo}:\")\n        print(f\"  Precio promedio: {promedio:.2f}\")\n        print(f\"  Mínimo: {minimo:.2f}, Máximo: {maximo:.2f}\")\n        print(f\"  Variación anual: {variacion:.2f}%\")\n    \n    return resultados\n\n# Descomentar para ejecutar el análisis más amplio\n# datos_ejemplo = generar_datos_ejemplo()"
      },
      {
        "path": "utilidades_mcp.py",
        "language": "python",
        "content": "\"\"\"\nUtilidades adicionales para el MCP con yfinance\nIncluye análisis y visualización de datos para el mercado argentino\n\"\"\"\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom typing import List, Dict, Optional, Tuple\nfrom datetime import datetime, timedelta\nimport logging\n\n# Importamos las clases del MCP principal\nfrom main import (\n    ClienteYFinanceMCP, SolicitudHistorico, Intervalo, Cotizacion, \n    EstadoRespuesta, TipoActivo, Mercado, Moneda, PanelMercado\n)\n\nclass AnalizadorMercadoArgentino:\n    \"\"\"Clase para realizar análisis del mercado argentino\"\"\"\n    \n    def __init__(self):\n        self.cliente = ClienteYFinanceMCP()\n        self.logger = logging.getLogger(\"AnalizadorMercadoArgentino\")\n    \n    def obtener_dataframe_historico(self, simbolo: str, desde: datetime, hasta: datetime = None,\n                                  intervalo: Intervalo = Intervalo.DIA_1) -> Optional[pd.DataFrame]:\n        \"\"\"Obtiene un DataFrame con datos históricos para un símbolo\"\"\"\n        if hasta is None:\n            hasta = datetime.now()\n            \n        solicitud = SolicitudHistorico(\n            simbolo=simbolo,\n            desde=desde,\n            hasta=hasta,\n            intervalo=intervalo\n        )\n        \n        respuesta = self.cliente.obtener_historico(solicitud)\n        \n        if respuesta.estado != EstadoRespuesta.OK or not respuesta.datos:\n            self.logger.warning(f\"No se pudieron obtener datos para {simbolo}: {respuesta.mensaje}\")\n            return None\n            \n        # Convertir los datos a DataFrame\n        datos = []\n        for cotizacion in respuesta.datos:\n            datos.append({\n                'fecha': cotizacion.timestamp,\n                'simbolo': cotizacion.simbolo,\n                'apertura': cotizacion.apertura,\n                'maximo': cotizacion.maximo,\n                'minimo': cotizacion.minimo,\n                'cierre': cotizacion.cierre,\n                'volumen': cotizacion.volumen_nominal\n            })\n            \n        df = pd.DataFrame(datos)\n        df.set_index('fecha', inplace=True)\n        return df\n    \n    def calcular_rendimiento(self, df: pd.DataFrame) -> Tuple[float, float, float]:\n        \"\"\"Calcula el rendimiento para un DataFrame de cotizaciones\"\"\"\n        if df is None or df.empty:\n            return 0.0, 0.0, 0.0\n            \n        primer_precio = df['cierre'].iloc[0]\n        ultimo_precio = df['cierre'].iloc[-1]\n        \n        # Rendimiento total\n        rendimiento_total = (ultimo_precio - primer_precio) / primer_precio * 100\n        \n        # Rendimiento anualizado\n        dias = (df.index[-1] - df.index[0]).days\n        if dias > 0:\n            rendimiento_anualizado = ((1 + rendimiento_total/100) ** (365/dias) - 1) * 100\n        else:\n            rendimiento_anualizado = 0.0\n            \n        # Volatilidad (desviación estándar de rendimientos diarios)\n        rendimientos_diarios = df['cierre'].pct_change() * 100\n        volatilidad = rendimientos_diarios.std()\n        \n        return rendimiento_total, rendimiento_anualizado, volatilidad\n    \n    def comparar_activos(self, simbolos: List[str], desde: datetime, \n                         hasta: datetime = None) -> Dict[str, Dict]:\n        \"\"\"Compara el rendimiento de varios activos\"\"\"\n        if hasta is None:\n            hasta = datetime.now()\n            \n        resultados = {}\n        \n        for simbolo in simbolos:\n            df = self.obtener_dataframe_historico(simbolo, desde, hasta)\n            if df is not None:\n                rendimiento_total, rendimiento_anualizado, volatilidad = self.calcular_rendimiento(df)\n                \n                # Calcular otros indicadores\n                maximo = df['cierre'].max()\n                minimo = df['cierre'].min()\n                ultima = df['cierre'].iloc[-1]\n                volumen_promedio = df['volumen'].mean()\n                \n                resultados[simbolo] = {\n                    'rendimiento_total': rendimiento_total,\n                    'rendimiento_anualizado': rendimiento_anualizado,\n                    'volatilidad': volatilidad,\n                    'precio_maximo': maximo,\n                    'precio_minimo': minimo,\n                    'precio_actual': ultima,\n                    'volumen_promedio': volumen_promedio,\n                    'cantidad_datos': len(df)\n                }\n                \n                # Obtener información del activo\n                activo = self.cliente.obtener_activo(simbolo)\n                if activo:\n                    resultados[simbolo]['denominacion'] = activo.denominacion\n                    resultados[simbolo]['tipo'] = activo.tipo.value\n                    resultados[simbolo]['mercado'] = activo.mercado.value\n                    resultados[simbolo]['moneda'] = activo.moneda.value\n            else:\n                self.logger.warning(f\"No se pudieron obtener datos para {simbolo}\")\n                \n        return resultados\n    \n    def graficar_comparacion(self, simbolos: List[str], desde: datetime, \n                            hasta: datetime = None, normalizado: bool = True) -> None:\n        \"\"\"Genera un gráfico comparativo entre varios activos\"\"\"\n        if hasta is None:\n            hasta = datetime.now()\n            \n        plt.figure(figsize=(12, 6))\n        \n        # Obtener datos para cada símbolo\n        for simbolo in simbolos:\n            df = self.obtener_dataframe_historico(simbolo, desde, hasta)\n            \n            if df is not None:\n                # Si normalizado, convertir a base 100\n                if normalizado:\n                    precios = df['cierre'] / df['cierre'].iloc[0] * 100\n                    label = f\"{simbolo} (var: {precios.iloc[-1] - 100:.2f}%)\"\n                else:\n                    precios = df['cierre']\n                    label = simbolo\n                    \n                plt.plot(df.index, precios, label=label)\n            \n        # Configuración del gráfico\n        titulo = \"Comparación de activos - \"\n        titulo += \"Normalizado (Base 100)\" if normalizado else \"Precios absolutos\"\n        plt.title(titulo)\n        plt.xlabel(\"Fecha\")\n        plt.ylabel(\"Valor\" if normalizado else \"Precio\")\n        plt.grid(True, linestyle='--', alpha=0.7)\n        plt.legend()\n        \n        # Mostrar gráfico\n        plt.tight_layout()\n        plt.show()\n    \n    def calcular_matriz_correlacion(self, simbolos: List[str], desde: datetime, \n                                   hasta: datetime = None) -> Optional[pd.DataFrame]:\n        \"\"\"Calcula la matriz de correlación entre varios activos\"\"\"\n        if hasta is None:\n            hasta = datetime.now()\n            \n        # Obtener datos para cada símbolo y almacenarlos en un DataFrame consolidado\n        datos_combinados = pd.DataFrame()\n        \n        for simbolo in simbolos:\n            df = self.obtener_dataframe_historico(simbolo, desde, hasta)\n            \n            if df is not None:\n                # Añadir la columna de cierre al DataFrame combinado\n                datos_combinados[simbolo] = df['cierre']\n        \n        if datos_combinados.empty:\n            self.logger.warning(\"No se pudieron obtener datos para ninguno de los símbolos\")\n            return None\n        \n        # Calcular rendimientos diarios\n        rendimientos = datos_combinados.pct_change().dropna()\n        \n        # Calcular matriz de correlación\n        matriz_correlacion = rendimientos.corr()\n        \n        return matriz_correlacion\n    \n    def calcular_beta(self, simbolo: str, indice: str = \"MERVAL\", \n                     desde: datetime = None, hasta: datetime = None) -> Optional[float]:\n        \"\"\"Calcula el beta de un activo respecto a un índice (por defecto Merval)\"\"\"\n        if desde is None:\n            desde = datetime.now() - timedelta(days=365)\n        if hasta is None:\n            hasta = datetime.now()\n            \n        # Obtener datos del activo y del índice\n        df_activo = self.obtener_dataframe_historico(simbolo, desde, hasta)\n        df_indice = self.obtener_dataframe_historico(indice, desde, hasta)\n        \n        if df_activo is None or df_indice is None:\n            return None\n            \n        # Asegurarse de que ambos DataFrames tengan las mismas fechas\n        fechas_comunes = df_activo.index.intersection(df_indice.index)\n        \n        if len(fechas_comunes) < 30:  # Requerir al menos 30 datos\n            self.logger.warning(f\"Datos insuficientes para calcular beta de {simbolo}\")\n            return None\n            \n        # Filtrar ambos DataFrames para tener las mismas fechas\n        df_activo = df_activo.loc[fechas_comunes]\n        df_indice = df_indice.loc[fechas_comunes]\n        \n        # Calcular rendimientos\n        rendimientos_activo = df_activo['cierre'].pct_change().dropna()\n        rendimientos_indice = df_indice['cierre'].pct_change().dropna()\n        \n        # Calcular beta: Cov(r_a, r_m) / Var(r_m)\n        covarianza = rendimientos_activo.cov(rendimientos_indice)\n        varianza = rendimientos_indice.var()\n        \n        if varianza == 0:\n            return None\n            \n        beta = covarianza / varianza\n        \n        return beta\n    \n    def calcular_ratios(self, simbolo: str, tasa_libre_riesgo: float = 0.01,\n                       desde: datetime = None, hasta: datetime = None) -> Dict[str, float]:\n        \"\"\"Calcula ratios financieros para un activo\"\"\"\n        if desde is None:\n            desde = datetime.now() - timedelta(days=365)\n        if hasta is None:\n            hasta = datetime.now()\n            \n        df = self.obtener_dataframe_historico(simbolo, desde, hasta)\n        \n        if df is None:\n            return {}\n            \n        # Calcular rendimientos diarios\n        rendimientos_diarios = df['cierre'].pct_change().dropna()\n        \n        # Rendimiento anualizado\n        rendimiento_anualizado = (1 + rendimientos_diarios.mean()) ** 252 - 1\n        \n        # Volatilidad anualizada\n        volatilidad_anualizada = rendimientos_diarios.std() * np.sqrt(252)\n        \n        # Ratio de Sharpe\n        sharpe = (rendimiento_anualizado - tasa_libre_riesgo) / volatilidad_anualizada if volatilidad_anualizada != 0 else 0\n        \n        # Sortino (usando solo los rendimientos negativos)\n        rendimientos_negativos = rendimientos_diarios[rendimientos_diarios < 0]\n        volatilidad_downside = rendimientos_negativos.std() * np.sqrt(252) if not rendimientos_negativos.empty else volatilidad_anualizada\n        sortino = (rendimiento_anualizado - tasa_libre_riesgo) / volatilidad_downside if volatilidad_downside != 0 else 0\n        \n        # Drawdown máximo\n        acumulado = (1 + rendimientos_diarios).cumprod()\n        maximo_valor = acumulado.cummax()\n        drawdown = (acumulado - maximo_valor) / maximo_valor\n        max_drawdown = drawdown.min() * 100\n        \n        return {\n            'rendimiento_anualizado': rendimiento_anualizado * 100,\n            'volatilidad_anualizada': volatilidad_anualizada * 100,\n            'ratio_sharpe': sharpe,\n            'ratio_sortino': sortino,\n            'maximo_drawdown': max_drawdown\n        }\n    \n    def generar_reporte_mercado(self, desde: datetime = None) -> Dict:\n        \"\"\"Genera un reporte general del mercado argentino\"\"\"\n        if desde is None:\n            desde = datetime.now() - timedelta(days=90)\n            \n        # Principales activos para analizar\n        lideres = [\"GGAL\", \"YPFD\", \"PAMP\", \"TXAR\", \"BYMA\", \"BBAR\", \"ALUA\"]\n        indices = [\"MERVAL\"]\n        \n        # Obtener datos de índices\n        datos_indices = {}\n        for indice in indices:\n            df = self.obtener_dataframe_historico(indice, desde)\n            if df is not None:\n                rendimiento_total, rendimiento_anualizado, volatilidad = self.calcular_rendimiento(df)\n                datos_indices[indice] = {\n                    'rendimiento_total': rendimiento_total,\n                    'rendimiento_anualizado': rendimiento_anualizado,\n                    'volatilidad': volatilidad,\n                    'ultimo_valor': df['cierre'].iloc[-1]\n                }\n        \n        # Obtener datos de líderes\n        datos_lideres = self.comparar_activos(lideres, desde)\n        \n        # Calcular matriz de correlación\n        todos_simbolos = lideres + indices\n        matriz_correlacion = self.calcular_matriz_correlacion(todos_simbolos, desde)\n        \n        # Calcular betas de los líderes respecto al Merval\n        betas = {}\n        for simbolo in lideres:\n            beta = self.calcular_beta(simbolo, \"MERVAL\", desde)\n            if beta is not None:\n                betas[simbolo] = beta\n        \n        # Preparar reporte\n        reporte = {\n            'fecha_reporte': datetime.now(),\n            'periodo': {\n                'desde': desde,\n                'hasta': datetime.now()\n            },\n            'indices': datos_indices,\n            'lideres': datos_lideres,\n            'betas': betas,\n            'matriz_correlacion': matriz_correlacion\n        }\n        \n        return reporte\n    \n    def imprimir_reporte(self, reporte: Dict) -> None:\n        \"\"\"Imprime un reporte de mercado en formato legible\"\"\"\n        print(\"=\" * 80)\n        print(f\"REPORTE DE MERCADO ARGENTINO - {reporte['fecha_reporte'].strftime('%d/%m/%Y %H:%M')}\")\n        print(\"=\" * 80)\n        \n        # Información del período\n        print(f\"\\nPeríodo analizado: {reporte['periodo']['desde'].strftime('%d/%m/%Y')} al {reporte['periodo']['hasta'].strftime('%d/%m/%Y')}\")\n        \n        # Datos de índices\n        print(\"\\nINDICES DE MERCADO:\")\n        print(\"-\" * 80)\n        print(f\"{'Indice':<10} {'Último Valor':<15} {'Rend. Total':<15} {'Rend. Anual':<15} {'Volatilidad':<15}\")\n        print(\"-\" * 80)\n        \n        for indice, datos in reporte['indices'].items():\n            print(f\"{indice:<10} {datos['ultimo_valor']:<15,.2f} {datos['rendimiento_total']:<15,.2f}% {datos['rendimiento_anualizado']:<15,.2f}% {datos['volatilidad']:<15,.2f}%\")\n        \n        # Datos de líderes\n        print(\"\\nACCIONES LÍDERES:\")\n        print(\"-\" * 80)\n        print(f\"{'Símbolo':<10} {'Denominación':<25} {'Último Precio':<15} {'Rend. Total':<15} {'Beta':<10}\")\n        print(\"-\" * 80)\n        \n        for simbolo, datos in reporte['lideres'].items():\n            beta = reporte['betas'].get(simbolo, 'N/A')\n            beta_str = f\"{beta:.2f}\" if isinstance(beta, float) else beta\n            denominacion = datos.get('denominacion', simbolo)[:25]\n            print(f\"{simbolo:<10} {denominacion:<25} {datos['precio_actual']:<15,.2f} {datos['rendimiento_total']:<15,.2f}% {beta_str:<10}\")\n        \n        # Top 3 rendimientos\n        print(\"\\nTOP 3 RENDIMIENTOS:\")\n        top_rendimientos = sorted(\n            [(s, d['rendimiento_total']) for s, d in reporte['lideres'].items()],\n            key=lambda x: x[1], reverse=True\n        )[:3]\n        \n        for i, (simbolo, rendimiento) in enumerate(top_rendimientos, 1):\n            print(f\"{i}. {simbolo}: {rendimiento:.2f}%\")\n        \n        # Matriz de correlación (simplificada)\n        if reporte['matriz_correlacion'] is not None:\n            print(\"\\nMATRIZ DE CORRELACIÓN (Extracto):\")\n            mat_corr = reporte['matriz_correlacion']\n            \n            # Si hay muchos símbolos, mostrar solo una parte\n            if len(mat_corr) > 5:\n                simbolos_muestra = mat_corr.index[:5]\n                print(mat_corr.loc[simbolos_muestra, simbolos_muestra].round(2))\n            else:\n                print(mat_corr.round(2))\n        \n        print(\"\\n\" + \"=\" * 80)\n\n# Ejemplo de uso\ndef ejemplo_uso_utilidades():\n    # Inicializar analizador\n    analizador = AnalizadorMercadoArgentino()\n    \n    print(\"Generando reporte de mercado argentino...\\n\")\n    desde = datetime.now() - timedelta(days=90)\n    reporte = analizador.generar_reporte_mercado(desde)\n    analizador.imprimir_reporte(reporte)\n    \n    # Análisis de correlación entre GGAL y YPFD\n    print(\"\\nAnalizando correlación entre GGAL y YPFD:\")\n    matriz_corr = analizador.calcular_matriz_correlacion([\"GGAL\", \"YPFD\"], desde)\n    if matriz_corr is not None:\n        print(matriz_corr.round(2))\n    \n    # Análisis de ratios financieros para GGAL\n    print(\"\\nRatios financieros para GGAL:\")\n    ratios = analizador.calcular_ratios(\"GGAL\", desde=desde)\n    for nombre, valor in ratios.items():\n        print(f\"{nombre}: {valor:.2f}\")\n    \n    # Ejemplo de gráfico (comentado porque no se puede mostrar en consola)\n    # analizador.graficar_comparacion([\"GGAL\", \"YPFD\", \"MERVAL\"], desde, normalizado=True)\n\nif __name__ == \"__main__\":\n    ejemplo_uso_utilidades()"
      }
    ]
  }
}